---
import Link from '../components/Link/Link'
import Pagination from '../components/Pagination.astro'
import ScrollUp from '../components/ScrollUp.astro'
import { CATS_ENDPOINT, CONTRIBUTORS_ENDPOINT, LINKS_ENDPOINT } from '../constants'
import Layout from '../layouts/Layout.astro'
import {
Periods,
type CategoryContributor,
type CategoryCount,
type PaginatedLinks,
type Period,
} from '../types'

// Auth
const token = Astro.cookies.get('token')?.value
const user = Astro.cookies.get('user')?.value

// Params
let page = 1
if (Astro.url.searchParams.get('page')) {
	page = parseInt(Astro.url.searchParams.get('page') as string)
}
let cats: string | undefined
if (Astro.url.searchParams.get('cats')) {
	cats = Astro.url.searchParams.get('cats') as string
}
let period: Period = 'all'
let other_periods: Period[] = Periods.filter((other) => other !== 'all')
if (
	Astro.url.searchParams.get('period') &&
	(Periods as readonly string[]).includes(
		Astro.url.searchParams.get('period') as Period
	)
) {
	period = Astro.url.searchParams.get('period') as Period
	other_periods = Periods.filter((other) => other !== period)
}

// Get links
let links_url = LINKS_ENDPOINT

let has_period = false
if (period !== 'all') {
	has_period = true
	links_url += `?period=${period}`
}
let has_cats = false
if (cats) {
	has_cats = true

	if (has_period) {
		links_url += `&cats=${cats}`
	} else {
		links_url += `?cats=${cats}`
	}
}
if (has_period || has_cats) {
	links_url += `&page=${page}`
} else {
	links_url += `?page=${page}`
}

const get_links_resp = await (token
	? fetch(links_url, {
			headers: { Authorization: `Bearer ${token}` },
		})
	: fetch(links_url))
const data: PaginatedLinks = await get_links_resp.json()
const links = data.Links

let top_cats: CategoryCount[] = []
let top_subcats: CategoryCount[] = []
let top_contributors: CategoryContributor[] = []

if (links && links.length) {

	// Get subcategory counts and category contributors
	if (cats) {
		let subcats_url = CATS_ENDPOINT + `?cats=${cats}`
		let contributors_url = CONTRIBUTORS_ENDPOINT + `/${cats}`

		if (period !== 'all') {
			subcats_url += `?period=${period}`
			contributors_url += `?period=${period}`
		}

		const subcats_resp = await fetch(subcats_url)
		top_subcats = await subcats_resp.json()

		const contributors_resp = await fetch(contributors_url)
		top_contributors = await contributors_resp.json()
	
	// Get category counts
	} else {
		let cats_url = CATS_ENDPOINT
		if (period !== 'all') {
			cats_url += `?period=${period}`
		}

		const top_cats_resp = await fetch(cats_url)
		top_cats = await top_cats_resp.json()
		// [{Category: 'umvc3', Count: 1}, ...]
	}
}

const page_title =
	cats
		? cats
		: 'Top Rated'
---

<Layout Title='Welcome to the Open Internet Treasure Map (OITM)'>
	<main>
		<h1>
			{page_title}
		</h1>
		{period !== 'all' ? <h2 class="subtitle">({period.charAt(0).toUpperCase() + period.slice(1)})</h2> : null}
		<section id='search-filters'>
			<h2>Filters</h2>
			<div>
				<p>Period:</p>
				{
					other_periods.map((other) => (
						<a
							class='period'
							href={`/top?period=${other}${cats ? `&cats=${cats}` : ''}`}
						>
							{other}
						</a>
					))
				}
			</div>
			{
				cats ? (
					<div>
						<p>
							{cats.includes(',')
								? 'Cats: '
								: 'Cat: '}
						</p>
						<a href={`/top${period !== 'all' ? `?period=${period}` : ''}`}>Reset</a>
					</div>
				) : null
			}
		</section>

		{
			links && links.length ? (
				<>
					{top_cats.length ? (
						<section>
							<h2>Top Cats</h2>
							<ol id='top-cats'>
								{top_cats.map((cat) => (
									<li>
										<a
											href={`/top?cats=${cat.Category}${period !== 'all' ? `&period=${period}` : ''}`}
										>
											{cat.Category}
										</a>
										<span>({cat.Count})</span>
									</li>
								))}
							</ol>
						</section>
					) : (
						<>
							<section>
								<h2>Top Subcats</h2>
								{top_subcats.length ? (
									<ol id='top-cats'>
										{top_subcats.map((subcat) => (
											<li>
												<a
													href={`/top?cats=${cats + ',' + subcat.Category}${period !== 'all' ? `&period=${period}` : ''}`}
												>
													{subcat.Category}
												</a>
												<span> ({subcat.Count})</span>
											</li>
										))}
									</ol>
								) : (
									<p>No further subcats</p>
								)}
							</section>
							<section>
								<h2>Top Contributors</h2>
								<ol id="top-contributors">
									{top_contributors.map(
										(contributor: CategoryContributor) => (
											<li>
												<strong>
													<a
														href={`/map/${contributor.LoginName}`}
													>
														{contributor.LoginName}
													</a>
												</strong>
												<span>
													({contributor.LinksSubmitted})
												</span>
											</li>
										)
									)}
								</ol>
							</section>
						</>
					)}

					<section>
						<h2>Top Links</h2>

						<Pagination
							Period={period}
							Page={page}
							NextPage={data.NextPage}
						/>

						{/* TODO: replace magic page limit number */}
						<ol id='top-links' start={(page - 1) * 20 + 1}>
							{links.map((link) => (
								<Link
									client:load
									CatsFromUser={link.TagCount === 1 && link.SubmittedBy === user ? user : undefined}
									IsSummaryPage={false}
									IsTagPage={false}
									Link={link}
									Token={token}
									User={user}
								/>
							))}
						</ol>

						{data.NextPage > 0 ? (
							<Pagination
								Period={period}
								Page={page}
								NextPage={data.NextPage}
							/>
						) : null}
					</section>

					<ScrollUp />
				</>
			) : (
				<section>
					<p>No links found</p>
					{user ? (
						<p>
							<a href={`/new`}>Add link</a>
						</p>
					) : null}
				</section>
			)
		}
	</main>
</Layout>

<style>
	#search-filters {
		div {
			display: flex;
			align-items: center;
		}

		p {
			margin-top: 0;
		}

		a {
			margin-left: 5px;
		}
	}

	#top-contributors {
		margin: 0;
		padding: 0;
		list-style-position: inside;
	}

	:is(li a, li strong:has(a)):has(+ span) {
		display: inline-block;
	}
</style>
